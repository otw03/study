# 05-기본 문법 활용
[01. 변수의 유효성 범위 (변수의 스코프)](#01-변수의-유효성-범위-변수의-스코프)  
[- 1) var 키워드로 선언된 변수의 경우](#1-var-키워드로-선언된-변수의-경우)  
[- 2) let 키워드로 선언된 변수와 const 키워드로 선언된 상수의 경우](#2-let-키워드로-선언된-변수와-const-키워드로-선언된-상수의-경우)  
[- 3) for문의 초기식에 대한 유효성 범위](#3-for문의-초기식에-대한-유효성-범위)  
[- 4) 선언되지 않은 변수의 경우](#4-선언되지-않은-변수의-경우)  
[02. if문 안에 포함된 흐름제어](#02-if문-안에-포함된-흐름제어)  
[- 1) if-if구조](#1-if-if구조)  
[- 2) if-for 구조](#2-if-for-구조)  
[03. for문 안에서의 흐름제어](#03-for문-안에서의-흐름제어)  
[- 1) 반복문 안에서의 조건문](#1-반복문-안에서의-조건문)  
[- 2) For문 안의 For문](#2-for문-안의-for문)  
[- 3) 반복범위 동적설정](#3-반복범위-동적설정)  
[- 4) 반복문 안에서의 흐름 제어](#4-반복문-안에서의-흐름-제어)  

- 변수, 연산자, 기본 문법을 활용하여 주어진 문제 해결
- 중첩된 반복문으로 구성된 프로그램을 작성하여 문제를 해결할 수 있다.
- 조건문 안에 반복문을 배치하여 주어진 문제를 해결할 수 있다.
- 반복문 안에 조건문을 배치하여 반복 수행 도중에 조건을 검사할 수 있다.
- 반복문을 중첩하여 주어진 문제를 해결할 수 있다.

---

# 01. 변수의 유효성 범위 (변수의 스코프)

## 1) var 키워드로 선언된 변수의 경우

블록 '{}' 안에서 선언된 변수는 블록의 실행 여부에 따라 블록 밖에서의 식별 여부가 결정됨.  

블록 '{}'을 갖는 부분이 실행되지 않을 경우 블록 안에서 선언된 변수를 블록 밖에서 사용할 경우 할당되지 않은 undefined가 됨  

### var 중복 선언

```jsx
// 조건문이 실행되지 않는 경우
if(false) {
    var num1 = 100;
    console.log("블록안: " + num1);
}

// if문의 실행 여부에 따라 num1이 선언되므로
// if문의 실행 여부에 num1의 식별 가능 여부가 결정됨
// num1을 식별하지 못할 경우 정의되지 않은 값(undefined)가 된다.
console.log("블록밖: " + num1);

// 조건문이 실행되는 경우
if(true) {
    var num2 = 100;
    console.log("블록안: " + num2);
}

console.log("블록밖: " + num2);
```

출력 결과

```
블록밖: undefined
블록안: 100
블록밖: 100
```

## 2) let 키워드로 선언된 변수와 const 키워드로 선언된 상수의 경우

블록 밖에서 선언된 변수는 블록 안으로 침투할 수 있지만 블록 안에서 선언된 변수는 블록을 빠져나올 수 없음.  

변수의 범위가 블록안으로 한정되므로 서로 다른 블록끼리는 중복 선언 가능  

### let 중복 선언

```jsx
let num3 = 100;

if(true) {
    // 블록 밖에서 생성된 변수를 블록 안에서 사용 가능
    let num4 = num3 + 100;
    console.log("블록안: " + num4);
}

// let으로 선언된 변수는 if문의 실행 여부와 상관 없이 블록을 빠져나올 수 없다.
// --> 프로그램 에러
console.log("블록밖: " + num4);
```

출력 결과

```
블록안: 200
c:\Users\otw\Documents\GitHub\study\codes\javascript\05-기본 문법 활용\tempCodeRunnerFile.js:11
console.log("블록밖: " + num4);
                      ^

ReferenceError: num4 is not defined
```

## 3) for문의 초기식에 대한 유효성 범위

var 키워드를 사용한 경우에는 초기식에서 선언된 변수가 for문 밖에서 식별 가능함.  

let 키워드를 사용한 경우에는 초기식에서 선언된 변수는 for문 밖에서 식별 할 수 없음.  

const 키워드를 사용한 경우 증감식으로 변수는 변환되지 않는다.  

### for문의 초기식을 var로 선언한 경우

```jsx
for (var i=0; i<10; i++) {
    console.log("반복문 안 ::: " + i);
}
console.log("반복문 밖 >>> " + i);
```

출력 결과

```
반복문 안 ::: 0
반복문 안 ::: 1
반복문 안 ::: 2
반복문 안 ::: 3
반복문 안 ::: 4
반복문 안 ::: 5
반복문 안 ::: 6
반복문 안 ::: 7
반복문 안 ::: 8
반복문 안 ::: 9
반복문 밖 >>> 10
```

### for문의 초기식을 let으로 선언한 경우

```jsx
for (let j=0; j<10; j++) {
    console.log("반복문 안 ::: " + j);
}

// for문의 초기식도 {}에 속한것으로 보기 때문에 j값은 for 블록을 빠져나올 수 없다.
console.log("반복문 밖 >>> " + j);
```

출력 결과

```
반복문 안 ::: 0
반복문 안 ::: 1
반복문 안 ::: 2
반복문 안 ::: 3
반복문 안 ::: 4
반복문 안 ::: 5
반복문 안 ::: 6
반복문 안 ::: 7
반복문 안 ::: 8
반복문 안 ::: 9
c:\Users\otw\Documents\GitHub\study\codes\javascript\05-기본 문법 활용\tempCodeRunnerFile.js:7
console.log("반복문 밖 >>> " + j);
                           ^

ReferenceError: j is not defined
```

---

## 4) 선언되지 않은 변수의 경우

### let 키워드의 할당 후 선언

```jsx
x = 100; // 할당
let x;   // 선언
console.log(x);
```

출력 결과

```
x = 100; // 할당
  ^

ReferenceError: Cannot access 'x' before initialization
```

### var 키워드는 할당 후 선언이 가능함.

```jsx
y = 200;
var y;
console.log(y);
```

출력 결과

```
200
```

---

# 02. if문 안에 포함된 흐름제어

## 1) if-if구조

특정 조건이 참으로 판단되어 블록안에 진입했을 때, 상세조건을 판별하는 구조.  

```jsx
if (조건) {
		if (조건) {
			...
		}
} else if (조건) {
		if (조건) {
			...
		} else {
			...
		}
} else {
		if (조건) {
			...
		} else if (조건) {
			...
		} else {
			...
		}
}
```

### 02-if,if.js

```jsx
const point = 78;

if(point >= 70) {
    console.log('Pass 입니다.');
    if(point > 90) {
        console.log('A');
    } else if(point > 80) {
        console.log('B');
    } else {
        console.log('C');
    }
} else {
    console.log('NonPass 입니다.');
}
```

출력결과

```
Pass 입니다.
C
```

## 2) if-for 구조

특정 조건이 참으로 판단되어 블록안에 진입했을 때, 반복을 수행하는 구조.  

```jsx
if (조건) {
  for (초기식; 조건식; 증감식) {
    ...
  }
}
```

### 03-if,for.js

```jsx
const k = 5;

// k의 범위를 결정하는 조건문
// -> k를 2~9 사이로 제한함
if(k>1 && k<10) {
    for(let i=1; i<10; i++) {
        console.log("%d x %d = %d", k, i, k*i);
    }
} else {
    console.log("2~9사이의 수식만 출력합니다.");
}
```

출력 결과

```
5 x 1 = 5
5 x 2 = 10
5 x 3 = 15
5 x 4 = 20
5 x 5 = 25
5 x 6 = 30
5 x 7 = 35
5 x 8 = 40
5 x 9 = 45
```

# 03. for문 안에서의 흐름제어

## 1) 반복문 안에서의 조건문

반복문 안에서 매 반복 수행시마다 조건을 판별한다.  

주로 반복문에 사용되는 조건값(=초기식에서 생성한 변수)에 대한 조건 판별을 위해 사용된다.  

### 04-for,if-짝홀수의_합.js

```jsx
let a = 0;  // 짝수의 합
let b = 0;  // 홀수의 합

// i가 1~10까지 1씩 증가하는 동안 반복
for(let i=1; i<=10; i++) {
    // 반복문 안에서의 조건문은 주로 반복문의 초기식 변수(i)에 대한 경우의 수를 판별함.
    if(i%2 == 0) {
        console.log("%d(은)는 짝수", i);
        a += i;
    } else {
        console.log("%d(은)는 홀수", i);
        b += i;
    }
}

console.log("1~10 까지 짝수들의 합: %d", a);
console.log("1~10 까지 홀수들의 합: %d", b);
```

출력 결과

```
1(은)는 홀수
2(은)는 짝수
3(은)는 홀수
4(은)는 짝수
5(은)는 홀수
6(은)는 짝수
7(은)는 홀수
8(은)는 짝수
9(은)는 홀수
10(은)는 짝수
1~10 까지 짝수들의 합: 30
1~10 까지 홀수들의 합: 25
```

### 05-for,if-공배수.js

공배수 구하기  

```jsx
// 어떤 수 i가 x로 나누어도 나머지가 0이고 y로 나누어도 나머지가 0일 때 이 수를 y의 공배수라고 한다.

// 1부터 100까지의 범위 안에서 3과 5의 공배수를 모두 출력하고 공배수의 총 합인 sum값을 구해 출력하시오.
const x = 3;
const y = 5;

// 공배수의 총 합을 저장할 변수
let sum = 0;

for(let i=0; i<=100; i++) {
    // if(i % (x*y) == 0) {
    if(i % x == 0 && i % y == 0) {
        console.log(i);
        sum += i;
    }
}

console.log("%d과 %d의 공배수의 총 합: %d", x, y, sum);
```

출력 결과

```
0
15
30
45
60
75
90
3과 5의 공배수의 총 합: 315
```

### 06-for,if-마지막_회차_생략.js

```jsx
// 1) 반복문의 조건식이 "변수 < 최댓값" 인 경우의 조건 : 변수 + i < 최댓값
// 1) 반복문의 조건식이 "변수 <= 최댓값" 인 경우의 조건 : 변수 < 최댓값

console.group("변수 < 최댓값");

for(let i=1; i<10; i++) {   // i는 1~9까지
    if(i + 1 < 10) {
        console.log(i);
    }
}

console.groupEnd();

console.group("변수 <= 최댓값");

for(let i=1; i<=9; i++) {   // i는 1~9까지
    if(i < 9) {
        console.log(i);
    }
}

console.groupEnd();

// 1~9까지의 숫자 사이사이에 콤마를 넣어 한 문장으로 결합
console.group("글자 사이에 콤마(,)넣기");

let str = "";

for(let i=1; i<10; i++) {
    str += i;

    if(i+1 < 10) {
        str += ",";
    }
}

console.log(str);
console.groupEnd();
```

출력 결과

```
변수 < 최댓값
  1
  2
  3
  4
  5
  6
  7
  8

변수 <= 최댓값
  1
  2
  3
  4
  5
  6
  7
  8

글자 사이에 콤마(,)넣기
  1,2,3,4,5,6,7,8,9
```

## 2) For문 안의 For문

바깥의 반복문(부모)이 1회 수행할 때 마다 안쪽의 반복문(자식)이 매번 처음부터 새로 시작하는 이중 반복문 구조.  

두 반복문간의 조건값이 서로 달라야 한다.  

### 07-for,for.js

이중 반복문  

바깥의 반복문(부모)이 1회 수행할 때 마다 안쪽의 반복문(자식)이 처음부터 새로 시작하는 이중 반복문구조.  
두 반복문간의 조건값이 서로 달라야 한다.  

```jsx
for(let i=0; i<3; i++) {    // -> 0~2

    console.group("i에 대한 반복 수행 시작 >> i=%d", i);

    for(let j=0; j<5; j++) {
        console.log("i=%d, j=%d", i, j);
    }

    console.groupEnd();
}
```

출력 결과

```
i에 대한 반복 수행 시작 >> i=0
  i=0, j=0
  i=0, j=1
  i=0, j=2
  i=0, j=3
  i=0, j=4
i에 대한 반복 수행 시작 >> i=1
  i=1, j=0
  i=1, j=1
  i=1, j=2
  i=1, j=3
  i=1, j=4
i에 대한 반복 수행 시작 >> i=2
  i=2, j=0
  i=2, j=1
  i=2, j=2
  i=2, j=3
  i=2, j=4
```

### 08-for,for-구구단.js

이중 반복문 구구단

```jsx
for(let i=2; i<10; i++) {    // -> 2~9

    console.group("%d단", i);

    for(let j=1; j<10; j++) {    // 1~9
        console.log("%d x %d = %d", i, j, i*j);
    }

    console.groupEnd();
}
```

출력 결과

```
2단
  2 x 1 = 2
  2 x 2 = 4
  2 x 3 = 6
  2 x 4 = 8
  2 x 5 = 10
  2 x 6 = 12
  2 x 7 = 14
  2 x 8 = 16
  2 x 9 = 18

...
...

9단
  9 x 1 = 9
  9 x 2 = 18
  9 x 3 = 27
  9 x 4 = 36
  9 x 5 = 45
  9 x 6 = 54
  9 x 7 = 63
  9 x 8 = 72
  9 x 9 = 81
```

## 3) 반복범위 동적설정

자식 반복문의 조건식이 부모 반복문의 조건변수를 활용하여 구성되면(새로운 값을 계산하면) 자식 반복문의 반복 범위에 변화를 줄 수 있다.  

```jsx
for(let i=0; i<5; i++) {

    console.group("i에 대한 반복 수행 시작 >> i=" + i);

    for(let j=0; j<i+1; j++) {
        console.log("i=%d, j=%d", i, j);
    }

    console.groupEnd();
}
```

출력 결과

```
i에 대한 반복 수행 시작 >> i=0
  i=0, j=0
i에 대한 반복 수행 시작 >> i=1
  i=1, j=0
  i=1, j=1
i에 대한 반복 수행 시작 >> i=2
  i=2, j=0
  i=2, j=1
  i=2, j=2
i에 대한 반복 수행 시작 >> i=3
  i=3, j=0
  i=3, j=1
  i=3, j=2
  i=3, j=3
i에 대한 반복 수행 시작 >> i=4
  i=4, j=0
  i=4, j=1
  i=4, j=2
  i=4, j=3
  i=4, j=4
```

### 10-for,for-별찍기.js

- i가 0일때 1회를 수행하기 위해서 `j < 1`
- i가 1일때 2회를 수행하기 위해서 `j < 2`
- i가 2일때 3회를 수행하기 위해서 `j < 3`
- i가 3일때 4회를 수행하기 위해서 `j < 4`
- i가 n일때 i+1회를 수행하기 위해서 `j < i+1`

```jsx
for(let i=0; i<7; i++) {        // 바깥의 반복문이 "행"을 담당 --> 7개의 행이 생성된다.

    // 이 위치에서 선언되는 변수는 부모 반복문이 실행될 때 마다 초기화 된다.
    let str = "";

    for(let j=0; j<i+1; j++) {  // 안쪽 반복문이 "열"을 담당
        str += "*";
    }

    console.log(str);
}
```

출력 결과

```
*
**
***
****
*****
******
*******
```

### 11-for,for-역순별찍기.js

- i가 0일때 7회를 수행하기 위해서 `j < 1`
- i가 1일때 6회를 수행하기 위해서 `j < 2`
- i가 2일때 5회를 수행하기 위해서 `j < 3`
- i가 3일때 4회를 수행하기 위해서 `j < 4`
- i가 n일때 7-i회를 수행하기 위해서 `j < 7-i`

```jsx
for(let i=0; i<7; i++) {        // 바깥의 반복문이 "행"을 담당 --> 7개의 행이 생성된다.

    let str = "";

    for(let j=0; j<7-i; j++) {  // 안쪽 반복문이 "열"을 담당
        str += "*";
    }

    console.log(str);
}
```

출력 결과

```
*******
******
*****
****
***
**
*
```

## 4) 반복문 안에서의 흐름 제어

### 무한루프

절대로 조건식이 종료되지 않는 형태의 반복문.  

```jsx
while (true) { // 무조건 반복. 종료되지 않는다 (무한루프)
	 ...
}
```

### 반복문 제어하기

반복을 몇 번 수행해야 하는지 판단할 수 없는 경우 무한루프 형태로 지정하고 특정 조건이 충족되는지에 따라 반복의 중단 여부를 결정한다.  

반복문의 흐름제어 기능을 갖는 키워드  

- `continue`: 조건식으로 강제 이동 (for문의 경우는 증감식으로 이동함)
- `break`: 현재 반복문을 강제로 종료하고 블록을 빠져 나간다.

### 12-while-무한루프.js

while문의 무한루프 형식  

```jsx
let y = 0;

while (true) {
    y++;

    if(y % 2 == 0) {
        // 반복문의 흐름이 조건식으로 넘어가도록 제어
        continue;
    }

    // 반복이 종료될 조건을 반드시 지정
    if(y > 10) {
        // 반복의 수행을 강제로 종료하도록 제어
        break;
    }

    console.log("Hello World ::: %d", y);
}
```

출력 결과  

```
Hello World ::: 1
Hello World ::: 3
Hello World ::: 5
Hello World ::: 7
Hello World ::: 9
```

### 13-for-무한루프.js

for문의 무한루프 형식  

```jsx
for(let i=0; true; i++) {
    if(i % 2 == 0) {
        continue;
    }

    if(i > 10) {
        break;
    }

    console.log("Hello World ::: %d", i);
}
```

출력 결과  

```
Hello World ::: 1
Hello World ::: 3
Hello World ::: 5
Hello World ::: 7
Hello World ::: 9
```

